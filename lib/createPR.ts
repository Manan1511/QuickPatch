import { Octokit } from "@octokit/rest";
import type { Finding } from "./supabase";

/* ===== Types ===== */

export interface PRResult {
    pr_url: string;
    pr_number: number;
    branch: string;
}

/* ===== Main Function ===== */

export async function createFixPR(
    accessToken: string,
    owner: string,
    repo: string,
    defaultBranch: string,
    findings: Finding[]
): Promise<PRResult> {
    const octokit = new Octokit({ auth: accessToken });

    // 1. Get latest commit SHA for default branch
    const { data: refData } = await octokit.git.getRef({
        owner,
        repo,
        ref: `heads/${defaultBranch}`,
    });
    const latestCommitSha = refData.object.sha;

    // 2. Get the commit's tree SHA
    const { data: commitData } = await octokit.git.getCommit({
        owner,
        repo,
        commit_sha: latestCommitSha,
    });
    const baseTreeSha = commitData.tree.sha;

    // 3. Create a new branch
    const branchName = `quickpatch/fix-${Date.now()}`;
    await octokit.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${branchName}`,
        sha: latestCommitSha,
    });

    // 4. Build tree entries for each finding with a fix
    const fixableFindings = findings.filter((f) => f.fix && f.file);

    if (fixableFindings.length === 0) {
        throw new Error("No fixable findings to apply");
    }

    // Group findings by file (multiple findings may target the same file)
    const fileFixMap = new Map<string, string>();
    for (const finding of fixableFindings) {
        // Last fix for each file wins (in a real system, we'd merge fixes)
        fileFixMap.set(finding.file, finding.fix);
    }

    // Create blobs and tree entries
    const treeEntries: {
        path: string;
        mode: "100644";
        type: "blob";
        sha: string;
    }[] = [];

    for (const [filePath, fixContent] of fileFixMap) {
        // Create a new blob with the fixed content
        const { data: blobData } = await octokit.git.createBlob({
            owner,
            repo,
            content: fixContent,
            encoding: "utf-8",
        });

        treeEntries.push({
            path: filePath,
            mode: "100644",
            type: "blob",
            sha: blobData.sha,
        });
    }

    // 5. Create a new tree
    const { data: newTree } = await octokit.git.createTree({
        owner,
        repo,
        base_tree: baseTreeSha,
        tree: treeEntries,
    });

    // 6. Create a commit
    const { data: newCommit } = await octokit.git.createCommit({
        owner,
        repo,
        message: "fix: QuickPatch automated security fixes",
        tree: newTree.sha,
        parents: [latestCommitSha],
    });

    // 7. Update the branch ref to point to the new commit
    await octokit.git.updateRef({
        owner,
        repo,
        ref: `heads/${branchName}`,
        sha: newCommit.sha,
    });

    // 8. Build PR body â€” markdown checklist grouped by severity
    const prBody = buildPRBody(findings);

    // 9. Open the Pull Request
    const { data: prData } = await octokit.pulls.create({
        owner,
        repo,
        title: "[QuickPatch] Automated Security Fixes",
        body: prBody,
        head: branchName,
        base: defaultBranch,
    });

    return {
        pr_url: prData.html_url,
        pr_number: prData.number,
        branch: branchName,
    };
}

/* ===== PR Body Builder ===== */

function buildPRBody(findings: Finding[]): string {
    const SEVERITY_ORDER = ["critical", "high", "medium", "low"] as const;
    const SEVERITY_EMOJI: Record<string, string> = {
        critical: "ðŸ”´",
        high: "ðŸŸ ",
        medium: "ðŸ”µ",
        low: "âšª",
    };

    let body = `## ðŸ”’ QuickPatch Automated Security Fixes\n\n`;
    body += `This PR was automatically generated by [QuickPatch](https://quickpatch.dev) to address security vulnerabilities found in this repository.\n\n`;

    for (const severity of SEVERITY_ORDER) {
        const group = findings.filter((f) => f.severity === severity);
        if (group.length === 0) continue;

        const emoji = SEVERITY_EMOJI[severity];
        body += `### ${emoji} ${severity.charAt(0).toUpperCase() + severity.slice(1)} (${group.length})\n\n`;

        for (const finding of group) {
            body += `- [ ] **${finding.title}** â€” \`${finding.file}\`\n`;
            if (finding.description) {
                body += `  ${finding.description}\n`;
            }
        }
        body += "\n";
    }

    body += `---\n_Generated by QuickPatch â€¢ [Learn more](https://quickpatch.dev)_\n`;

    return body;
}
